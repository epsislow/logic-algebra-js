please check script_editor_v0_3_1_last_version.html and lib/main.js. 
I want a way to add devices from the script and give values or connect them to existing references, examples:

#when executing the script, on run() the devices() will be cleared.

2wire a = 11

comp [led] 1bit .power:
     text: "PWR"
     color: ^2ecc71
     = 0
     :

# this adds the device component .power that has a 1bit input 
# the text is the label attribute of the led that will be added in the devices  
# the color is the color attribute of the led 
# the = 0 is the value given when the devices is added 
# it should execute the js function: 
#addLed({
#  id: someGeneratedStringId,
#  text: "PWR",
#  color: "#2ecc71",
#  value: true
#});


.power = a.0
#this connects the value of the led to the reference a.0 -> the first bit of a is 1 -> led lights on
#this means that if a.0 value changes the led should show the change 
# executs the js function
# setLed( someGeneratedStringId, true);


a = 00
#when this assignment happens because the first bit of a is now 0 -> led lights off
# executs the js function
# setLed( someGeneratedStringId, false)

a.0 = 1
#when this assignment happens because the first bit of a is now 1 -> led lights on
# executs the js function
# setLed( someGeneratedStringId, true)

comp [led] 1bit .error:
     color: ^f44
     text:"ERR"
     :
#the attributes can be given in any order, the color can be short like in css
#value can be missed this means it will be 0
#will execute:
#addLed({
#  id: someGeneratedStringId2,
#  text: "ERR",
#  color: "#f44",
#  value: false
#});

.error = 1
.power = 0

comp [led] 1bit .test:
   color: ^f0f,
   radius: 0
   :
#text can be missed this means it won't have a label 
#radius is another attribute that gets into the js execution
#will execute:
#addLed({
#  id: someGeneratedStringId3,
#  color: "#f0f",
#  radius: 0,
#  value: false
#});


comp [led] 6bit .l:
    color: ^00ff99
    text: "OUT"
    radius: 0
    nl
    :
#this led has 6bits this means it converts into 6 consecutive leds
#the text is for the first led js execution
#nl attribute translates into the js execution as nl: true in the last led 
#will execute a js like this:
#addLed({ text: 'OUT',  id: "l.1", color: "#00ff99", value: false, radius:0 });
#addLed({ id: "l.2", color: "#00ff99", value: false, radius:0 });
#addLed({ id: "l.3", color: "#00ff99", value: false, radius:0 });
#addLed({ id: "l.4", color: "#00ff99", value: false, radius:0 });
#addLed({ id: "l.5", color: "#00ff99", value: false, radius:0 });
#addLed({ id: "l.6", color: "#00ff99", value: false, radius:0, nl: true });

.l = 000001
#this assignemnt will trigger the led light changes accordingly
#executes: 
#setLed("l.1", false);
#setLed("l.2", false);
#setLed("l.3", false);
#setLed("l.4", false);
#setLed("l.5", false);
#setLed("l.6", true);

comp [led] 6bit .t:
    color:^0f9
    text: "OUT2"
    radius: 0
    = 011011
    nl
    :

# the : is the return of the definition block and it means that the led components cannot be assigned to other values 

1bit ret = .t 
#this gives an error that ret cannot be assigned to a 0 bit component

comp [switch] 1bit .wifi:
    text: "WIFI"
    :1bit
#this is the switch component 
# the text is the label attribute
# it has a 1bit return that is the value that will change when the checkbox changes state (onclick)
# executes: 
#addSwitch({
#    text: "WIFI",
#    value: true,
#    onChange: state => someInternalInterpretorMethod
#});

.power = .wifi
#this is connects the .power led with the value of the .wifi switch
#when the .wifi checkbox is pressed it will execute the js someInternalInterpretorMethod and the value of the .power will change checked means = 1 not checked means 0
#it should execute a setLed()

.l.0 = .wifi 
#this also works
#this means that the first bit of .l comes from the state of the .wifi checkbox
#it should execute a setLed() 




The switches that are checkboxes will trigger changes because the coresponding components change the value of the conected references and those references are connected with other elements functions/statements inside script and those should also be processed.

2bit a = 01

comp [led] 1bit .power:
     text: "PWR"
     color: ^2ecc71
     = 0
     :


comp [switch] 1bit .wifi:
    text: "WIFI"
    :1bit


.power = .wifi


========
acum pentru programul:

2bit a = 01

comp [led] 1bit .power:
     text: "PWR"
     color: ^0000ff
     = 0
     :


comp [switch] 1bit .wifi:
    text: "WIFI"
    :1bit


.power = .wifi

afiseaza corect acum, dar cand apas pe checkbox  pare ca nu se schimba nimic 
Am adaugat un console.log la linia 3004:
console.log('CHECK ' , checked, compInfo);

if(compInfo){
          // Update the value in storage if component is connected
          if(compInfo.ref){
            const storageIdx = parseInt(compInfo.ref.substring(1));
                const stored = this.storage.find(s => s.index === storageIdx);
                if(stored){
                  stored.value = checked ? '1' : '0';
                  // Update all connected components
                  this.updateComponentConnections(name);
                }
          }
        }

vad in console ca ref = null :
CHECK  true 
Object { type: "switch", componentType: "1bit", attributes: {…}, initialValue: null, returnType: "1bit", ref: null, deviceIds: (1) […] }
​attributes: Object { text: "WIFI" }
componentType: "1bit"
deviceIds: Array [ "wifi" ]
initialValue: null
ref: null
returnType: "1bit"
type: "switch"
<prototype>: Object { … }

dar cred ca ref este referinta de intrare precum componenta LED care ii spune daca led este aprins sau nu 

pentru ca vad ca pe componenta led .power adica daca execut:
globalInterp.components.get('.power')

imi arata:
Object { type: "led", componentType: "1bit", attributes: {…}, initialValue: "0", returnType: null, ref: "(0)", deviceIds: (1) […] }
​attributes: Object { text: "PWR", color: "#0000FF" }​
componentType: "1bit"
deviceIds: Array [ "power" ]
initialValue: "0"
ref: "(0)"
returnType: null
type: "led"

iar switch nu are o astfel de referinta are doar de iesire,
ma gandesc ca ar trebuii sa fie referinte diferite daca o componenta poate sa aibe si referinta de intrare si de iesire?

.power = .wifi 
inseamna ca .wifi ar trebuii sa schimbe state-ul unei referinte de iesire deci sa aibe un storage nou. iar .power sa fie conectat cu referinta lui de intrare la referinta de iesire a lui .wifi 

astfel incat sa aprinda sau sa stinga ledul conform cu stateul butonului


===
as vrea sa modificam attributul radius pt componentele led sa se numeasca square
si sa nu mai fie folosit radius: 0 ci doar square adica:
in loc de 
comp [led] 1bit .power:
     text: "PWR"
     color: ^ff0
     radius: 0
     = 1
     :

sa scriem:
comp [led] 1bit .power:
     text: "PWR"
     color: ^ff0
     square
     = 1
     :

care executa in js atributul round: 0
iar daca square  lipseste atunci in js nu va trimite atributul round 

===== comp lcd/pcb ideas

16bit b = 1111011011110110

comp [7seg] 8bit .s1:
   text: "R"
   color: ^2c7
   :
comp [7seg] 8bit .s2:
   color: ^2c7
   nl
   :

.s1 = b.0/8
.s2 = b.8/8

comp [dip] 8bit .dp:
   text: "IN"
   color: ^f37
   :8bit

.b.0/8 = .dp

conp [lcd] 40bit .lcd1:
  row: 8
  cols: 5
  pixelSize: 7
  pixelGap: 1
  glow
  round: 0
  color: ^58f
  bg: ^000
  nl
  :
  
  
pcb [display] {
   1pin sel
   8pin data
   ...
   .lcd0 = bus8wire
#   8pout q
}


comp [display] 9bit .d2:



comp [lcd-ctrl] 8bit lcd1Ctrl:
   for: .lcd1
   :

1bit sel
5bit instr = 00001
3bit param = 101

.lcdCtrl = sel + instr + param
next
sel = 0
inste = 3
next


.lcd1 = ^7FF5 F301 4E

send .lcd1:
   x: 111
   y: 100
   len: 4
   data: ^035
   :

send .lcd1:
   clear
   color: ^f9f
   :




addCharacterLCD({
  id: "lcd2",
  rows: 8,
  cols: 30,
  pixelSize: 7,
  pixelGap:1,
  glow: true,
  pixelOnColor: "#5588ff",
  backgroundColor: "#000",
  round: false, 
  nl: true,
});


comp [key] 

====
vreau sa adaugam compoenta 7seg 
comp [7seg] 8bit .s1:
   text: "SEG"
   color: ^2ecc71
   = 00001111
   nl
   :
# text atribut pentru labelul pentru sevenSegment ca la celelalte componente
# color pentru culoare ca la celelalte componente
# nl ca la celelalte componente
# = seteaza valoarea de 8 biti data sau o referinta ca la celelalte componente
# executa js:
addSevenSegment({
  text: "SEG",
  color: "#2ecc71",
  values: "00001111"
});

# atributele sunt optionale ca la celalalte componente
comp [7seg] 8bit .s2:
   nl
   :
#executa doar
addSevenSegment({
    nl: true
});

=====
i want to add a new component called mem:

comp [mem] 4bit .ram:
   length: 3
   depth: 4
   = ^0
   :
#this should have a js function like addMem({ length: 3, depth: 4, default: "0000" })
#this component doesn't add anything to the display
#depth attribute sets the number of bits each memory address is having, default is 4 meaning 4 bits
#length attribute sets the number of addresses that exists in the memory component
#= is the default value that each address will have, must be the same bit length set with depth attribute


#should execute the addMem() js function like:
addMem({
 id: someGeneratedStringId5,
 length: 3,
 depth: 4,
 default: "0000"
});

#the addMem function should keep the memory data in an object or Map for each id 
#there should be also a js function called setMem( id, address, value) that sets the value of an memory address to the given value be also a js function called setMem( id, address, 
#there should be also a js function called getMem( id, address) and should return the value of the memory with given id and address, if the memory doesn't have a value set on that address should give the default value.
#the addMem should not create all the addresses initialy, just use the default functionality. if the default value is not set by default is 0 

#the attributes are optional like the rest of the components. the defaults are: length= 3, depth= 4 and each address have the value 0

.ram = ^FFF
#should give error: Cannot asign a value to a mem component


.ram:at = 00
#sets the memory address where we want to do some operation, must be between 0 and the given length, 
#.ram:at = 11 should give error: Memory invalid address 3 ( length: 3 means adress can be between 0,1 or 2)
.ram:data = ^5
#sets the value for the said address
.ram:set = 1
#the value is changed imediatly, 
.ram:set = ~
#the value is changed on the next NEXT(~)

.ram:at = 00
.ram:data = ^5F
.ram:set = 1
#this will change the memory values: for address 0 to bits of 5, and the next address 1 to bits of F
#you can perform multiple sets by given more bits to data, the number of bits must be divizibile with the depth number. If depth is 6 meaning 6bit then .ram:data must be 6bits, 12bits, 18bits, 24bits etc..

.ram:adr = 00
4bit val = .ram:get
#this assigns to val the value that exists at adresss 0 at component .ram, should use a js method like getMem(id, address)

.ram:get = 0
#this throws an error: Invalid get property cannot be assigned to a value

other examples:
comp [mem] 4bit .rom:
   depth: 8
   length: 256
   :
#this adds a mem componet called .rom with 8bits depth and 256 memory addresses default value is 00000000


.rom:at = 0
.rom:data = ^1234 5678 9ABC + ^DF
.rom:set = 1
#this sets 7 values for address 0 to 6 now

5bit adr = 00100
8bit val2 = ^0
.rom:at = adr
.rom:data = val2
.rom:set = ~
#this will set for address 5 the value 0 when NEXT(~)  will be executed
=====
