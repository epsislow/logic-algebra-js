please check script_editor_v0_3_1_last_version.html and lib/main.js. 
I want a way to add devices from the script and give values or connect them to existing references, examples:

#when executing the script, on run() the devices() will be cleared.

2wire a = 11

comp [led] 1bit .power:
     text: "PWR"
     color: ^2ecc71
     = 0
     :

# this adds the device component .power that has a 1bit input 
# the text is the label attribute of the led that will be added in the devices  
# the color is the color attribute of the led 
# the = 0 is the value given when the devices is added 
# it should execute the js function: 
#addLed({
#  id: someGeneratedStringId,
#  text: "PWR",
#  color: "#2ecc71",
#  value: true
#});


.power = a.0
#this connects the value of the led to the reference a.0 -> the first bit of a is 1 -> led lights on
#this means that if a.0 value changes the led should show the change 
# executs the js function
# setLed( someGeneratedStringId, true);


a = 00
#when this assignment happens because the first bit of a is now 0 -> led lights off
# executs the js function
# setLed( someGeneratedStringId, false)

a.0 = 1
#when this assignment happens because the first bit of a is now 1 -> led lights on
# executs the js function
# setLed( someGeneratedStringId, true)

comp [led] 1bit .error:
     color: ^f44
     text:"ERR"
     :
#the attributes can be given in any order, the color can be short like in css
#value can be missed this means it will be 0
#will execute:
#addLed({
#  id: someGeneratedStringId2,
#  text: "ERR",
#  color: "#f44",
#  value: false
#});

.error = 1
.power = 0

comp [led] 1bit .test:
   color: ^f0f,
   radius: 0
   :
#text can be missed this means it won't have a label 
#radius is another attribute that gets into the js execution
#will execute:
#addLed({
#  id: someGeneratedStringId3,
#  color: "#f0f",
#  radius: 0,
#  value: false
#});


comp [led] 6bit .l:
    color: ^00ff99
    text: "OUT"
    radius: 0
    nl
    :
#this led has 6bits this means it converts into 6 consecutive leds
#the text is for the first led js execution
#nl attribute translates into the js execution as nl: true in the last led 
#will execute a js like this:
#addLed({ text: 'OUT',  id: "l.1", color: "#00ff99", value: false, radius:0 });
#addLed({ id: "l.2", color: "#00ff99", value: false, radius:0 });
#addLed({ id: "l.3", color: "#00ff99", value: false, radius:0 });
#addLed({ id: "l.4", color: "#00ff99", value: false, radius:0 });
#addLed({ id: "l.5", color: "#00ff99", value: false, radius:0 });
#addLed({ id: "l.6", color: "#00ff99", value: false, radius:0, nl: true });

.l = 000001
#this assignemnt will trigger the led light changes accordingly
#executes: 
#setLed("l.1", false);
#setLed("l.2", false);
#setLed("l.3", false);
#setLed("l.4", false);
#setLed("l.5", false);
#setLed("l.6", true);

comp [led] 6bit .t:
    color:^0f9
    text: "OUT2"
    radius: 0
    = 011011
    nl
    :

# the : is the return of the definition block and it means that the led components cannot be assigned to other values 

1bit ret = .t 
#this gives an error that ret cannot be assigned to a 0 bit component

comp [switch] 1bit .wifi:
    text: "WIFI"
    :1bit
#this is the switch component 
# the text is the label attribute
# it has a 1bit return that is the value that will change when the checkbox changes state (onclick)
# executes: 
#addSwitch({
#    text: "WIFI",
#    value: true,
#    onChange: state => someInternalInterpretorMethod
#});

.power = .wifi
#this is connects the .power led with the value of the .wifi switch
#when the .wifi checkbox is pressed it will execute the js someInternalInterpretorMethod and the value of the .power will change checked means = 1 not checked means 0
#it should execute a setLed()

.l.0 = .wifi 
#this also works
#this means that the first bit of .l comes from the state of the .wifi checkbox
#it should execute a setLed() 




The switches that are checkboxes will trigger changes because the coresponding components change the value of the conected references and those references are connected with other elements functions/statements inside script and those should also be processed.

2bit a = 01

comp [led] 1bit .power:
     text: "PWR"
     color: ^2ecc71
     = 0
     :


comp [switch] 1bit .wifi:
    text: "WIFI"
    :1bit


.power = .wifi


========
acum pentru programul:

2bit a = 01

comp [led] 1bit .power:
     text: "PWR"
     color: ^0000ff
     = 0
     :


comp [switch] 1bit .wifi:
    text: "WIFI"
    :1bit


.power = .wifi

afiseaza corect acum, dar cand apas pe checkbox  pare ca nu se schimba nimic 
Am adaugat un console.log la linia 3004:
console.log('CHECK ' , checked, compInfo);

if(compInfo){
          // Update the value in storage if component is connected
          if(compInfo.ref){
            const storageIdx = parseInt(compInfo.ref.substring(1));
                const stored = this.storage.find(s => s.index === storageIdx);
                if(stored){
                  stored.value = checked ? '1' : '0';
                  // Update all connected components
                  this.updateComponentConnections(name);
                }
          }
        }

vad in console ca ref = null :
CHECK  true 
Object { type: "switch", componentType: "1bit", attributes: {…}, initialValue: null, returnType: "1bit", ref: null, deviceIds: (1) […] }
​attributes: Object { text: "WIFI" }
componentType: "1bit"
deviceIds: Array [ "wifi" ]
initialValue: null
ref: null
returnType: "1bit"
type: "switch"
<prototype>: Object { … }

dar cred ca ref este referinta de intrare precum componenta LED care ii spune daca led este aprins sau nu 

pentru ca vad ca pe componenta led .power adica daca execut:
globalInterp.components.get('.power')

imi arata:
Object { type: "led", componentType: "1bit", attributes: {…}, initialValue: "0", returnType: null, ref: "(0)", deviceIds: (1) […] }
​attributes: Object { text: "PWR", color: "#0000FF" }​
componentType: "1bit"
deviceIds: Array [ "power" ]
initialValue: "0"
ref: "(0)"
returnType: null
type: "led"

iar switch nu are o astfel de referinta are doar de iesire,
ma gandesc ca ar trebuii sa fie referinte diferite daca o componenta poate sa aibe si referinta de intrare si de iesire?

.power = .wifi 
inseamna ca .wifi ar trebuii sa schimbe state-ul unei referinte de iesire deci sa aibe un storage nou. iar .power sa fie conectat cu referinta lui de intrare la referinta de iesire a lui .wifi 

astfel incat sa aprinda sau sa stinga ledul conform cu stateul butonului


===
as vrea sa modificam attributul radius pt componentele led sa se numeasca square
si sa nu mai fie folosit radius: 0 ci doar square adica:
in loc de 
comp [led] 1bit .power:
     text: "PWR"
     color: ^ff0
     radius: 0
     = 1
     :

sa scriem:
comp [led] 1bit .power:
     text: "PWR"
     color: ^ff0
     square
     = 1
     :

care executa in js atributul round: 0
iar daca square  lipseste atunci in js nu va trimite atributul round 

===== comp lcd/pcb ideas

16bit b = 1111011011110110

comp [7seg] 8bit .s1:
   text: "R"
   color: ^2c7
   :
comp [7seg] 8bit .s2:
   color: ^2c7
   nl
   :

.s1 = b.0/8
.s2 = b.8/8

comp [dip] 8bit .dp:
   text: "IN"
   color: ^f37
   :8bit

.b.0/8 = .dp





  
pcb [display] {
   1pin sel
   8pin data
   ...
   .lcd0 = bus8wire
#   8pout q
}


comp [display] 9bit .d2:



comp [lcd-ctrl] 8bit lcd1Ctrl:
   for: .lcd1
   :

1bit sel
5bit instr = 00001
3bit param = 101

.lcdCtrl = sel + instr + param
next
sel = 0
inste = 3
next


.lcd1 = ^7FF5 F301 4E

send .lcd1:
   x: 111
   y: 100
   len: 4
   data: ^035
   :

send .lcd1:
   clear
   color: ^f9f
   :




addCharacterLCD({
  id: "lcd2",
  rows: 8,
  cols: 30,
  pixelSize: 7,
  pixelGap:1,
  glow: true,
  pixelOnColor: "#5588ff",
  backgroundColor: "#000",
  round: false, 
  nl: true,
});

Vreau sa adaugam componenta key care arata astfel:
comp [key] .kA:
   label: "A"
   size: 36
   nl
   :
#attributul size are valoarea default 36 daca lipseste atributul si poate fi asignat un alt numar
#attributul nl nu are valoare trebuie sa fie ca la alte componente vezi la switch sau dip
#se executa js function: 
addKey({
   label: "A",
   onPress: functie callback care este apelata atunci cand ii se schimba starea, vezi cum exista la alte componente metoda onChange
   size: 36,
   nl: true
});

  
1wire q = .ka

key se comporta ca un switch are un bit 1 cand e apasat si 0 cand nu e apasat, schimbarea starii se va trimite cand se apeleaza callbackul setat pe onPress



====
vreau sa adaugam compoenta 7seg 
comp [7seg] 8bit .s1:
   text: "SEG"
   color: ^2ecc71
   = 00001111
   nl
   :
# text atribut pentru labelul pentru sevenSegment ca la celelalte componente
# color pentru culoare ca la celelalte componente
# nl ca la celelalte componente
# = seteaza valoarea de 8 biti data sau o referinta ca la celelalte componente
# executa js:
addSevenSegment({
  text: "SEG",
  color: "#2ecc71",
  values: "00001111"
});

# atributele sunt optionale ca la celalalte componente
comp [7seg] 8bit .s2:
   nl
   :
#executa doar
addSevenSegment({
    nl: true
});

=====
i want to add a new component called mem:

comp [mem] 4bit .ram:
   length: 3
   depth: 4
   = ^0
   :
#this should have a js function like addMem({ length: 3, depth: 4, default: "0000" })
#this component doesn't add anything to the display
#depth attribute sets the number of bits each memory address is having, default is 4 meaning 4 bits
#length attribute sets the number of addresses that exists in the memory component
#= is the default value that each address will have, must be the same bit length set with depth attribute


#should execute the addMem() js function like:
addMem({
 id: someGeneratedStringId5,
 length: 3,
 depth: 4,
 default: "0000"
});

#the addMem function should keep the memory data in an object or Map for each id 
#there should be also a js function called setMem( id, address, value) that sets the value of an memory address to the given value be also a js function called setMem( id, address, 
#there should be also a js function called getMem( id, address) and should return the value of the memory with given id and address, if the memory doesn't have a value set on that address should give the default value.
#the addMem should not create all the addresses initialy, just use the default functionality. if the default value is not set by default is 0 

#the attributes are optional like the rest of the components. the defaults are: length= 3, depth= 4 and each address have the value 0

.ram = ^FFF
#should give error: Cannot asign a value to a mem component


.ram:at = 00
#sets the memory address where we want to do some operation, must be between 0 and the given length, 
#.ram:at = 11 should give error: Memory invalid address 3 ( length: 3 means adress can be between 0,1 or 2)
.ram:data = ^5
#sets the value for the said address
.ram:set = 1
#the value is changed imediatly, 
.ram:set = ~
#the value is changed on the next NEXT(~)

.ram:at = 00
.ram:data = ^5F
.ram:set = 1
#this will change the memory values: for address 0 to bits of 5, and the next address 1 to bits of F
#you can perform multiple sets by given more bits to data, the number of bits must be divizibile with the depth number. If depth is 6 meaning 6bit then .ram:data must be 6bits, 12bits, 18bits, 24bits etc..

.ram:adr = 00
4bit val = .ram:get
#this assigns to val the value that exists at adresss 0 at component .ram, should use a js method like getMem(id, address)

.ram:get = 0
#this throws an error: Invalid get property cannot be assigned to a value

other examples:
comp [mem] 4bit .rom:
   depth: 8
   length: 256
   :
#this adds a mem componet called .rom with 8bits depth and 256 memory addresses default value is 00000000


.rom:at = 0
.rom:data = ^1234 5678 9ABC + ^DF
.rom:set = 1
#this sets 7 values for address 0 to 6 now

5bit adr = 00100
8bit val2 = ^0
.rom:at = adr
.rom:data = val2
.rom:set = ~
#this will set for address 5 the value 0 when NEXT(~)  will be executed
=====

add counter component 

comp [counter] 5bit .c:
   depth: 5
   = 00100
   :
#this should have a js function like addCounter({ depth: 4, default: "0000" })
#if no default is set then use 0
#this should execute:
#addCounter({depth: 5, default: "00100" })


.c:dir = 1
#sets the direction to increment
.c:data = 10100
#sets the date to be 10100 
.c:set = 1
#the value is changed imediatly and because the direction is increment it will changed to 10101 
#if the value was 11111 then the increment should change it to 00000

.c:set = ~
#the value is changed on the next NEXT(~) 

.c:dir = 0
#sets the direction to decrement
.c:data = 00000
.c:set = 1
#the value is changed imediatly and because the direction is decrement it will be changed to 11111


show(.c:get) 
#this should show the current value of the counter meaning 11111
=========================


as vrea sa mai adaugam o componenta numita adder:
comp [adder] 4bit .add:
   depth: 4
   :

#this should have a js function like addAdder({ depth: 4})
#if no value was set for depth then use depth: 4

.add:a = 1011
.add:b = 0100
#sets the numbers a and b
show(.add:get)
#shows 1111

.add:a = 0001
.add:b = 1111
show(.add:get)
#shows 0000
show(.add:carry)
#shows 1. the carry value is the first overflow bit after the a + b calculation

.add:a = 0010
.add:b = 1111
show(.add:get)
#shows 0001
show(.add:carry)
#shows 1

comp [adder] 8bit .add:
   depth: 8
   :
   

.add:a = 00000001
.add:b = 00001111
show(.add:get)
#shows 00010000
show(.add:carry)
#shows 0 the value is 0 because the a+b calculation gave no carry

=====



as vrea sa mai adaugam o componenta numita subtract:
comp [subtract] 4bit .sub:
   depth: 4
   :

.sub:a = 1111
.sub:b = 0110
show(.sub:get)
#shows 1001 shows the result of a - b
show(.sub:carry)
#shows 0  shows the carry after a - b

.sub:a = 0000
.sub:b = 0001
show(.sub:get)
#shows 1111 shows the result of a - b
show(.sub:carry)
#shows 1  shows the carry after a - b

====
as vrea sa mai adaugam o componenta numita divider:
comp [divider] 4bit .div:
   depth: 4
   :

.div:a = 1110
.div:b = 0010
show(.div:get)
#shows 0111 shows the result of a / b
show(.div:mod)
#shows 0000 shows the modulo of a / b

.div:a = 0111
.div:b = 0010
show(div:get)
#shows 0011
show(.div:mod)
#shows 0001 
====
as vrea sa mai adaugam o componenta numita multiplier
comp [multiplier] 4bit .mul:
    depth: 4
    :
    
.mul:a = 0010
.mul:b = 0010
show(.mul:get)
#shows 0100 shows the result of a * b
show(.mul:over)
#shows 0000 shows the carry over after the result of a * b

.mul:a = 1111
.mul:b = 1111
show(.mul:get)
#shows 0001 shows the result of a * b
show(.mul:over)
#shows 1110 shows the carry over after the result of a * b

====

 i want to add a component for a shift register that can shift to left or to right 
comp [shifter] 8bit .sh:
   depth: 8
   :

.sh:value = 00110111
.sh:set = 1
#this should set this value in the shifter

that could be done with an attribute like direction :dir
.sh:dir = 1 
#meaning shifting to right or
.sh:dir = 0
#meaning shifting to left
.sh:set = 1
#the shifting is done now

show(.sh:get) 
#shows 00011011 shows the shifter value of 8bits and take into account if the shifter has circular set or not
show(.sh:out)
#shows 1 shows the bit that was shifted out 

comp [shifter] 8bit .sh2:
   depth: 8
   circular
   :
#this shifter is circular 

.sh:value = 00110111
.sh:dir = 0
.sh:set = 1
#the shifting is done now

show(.sh:get)
#shows 10011011
show(.sh:out)
#shows 1 shows the bit that was shifted out 


== 
i want to add :in for the shifter component:
comp [shifter] 5bit .sh2:
   depth: 5
   :

.sh:value = 00010
.sh:set = 1
.sh:in = 1
# this will be used when the shifter is not circular, 
# and will use the bit to the shifter like folowing:
.sh:dir = 1
.sh:set = 1
show(.sh:get)
# shows 10001 the first bit comes from the in bit if it was .sh:in = 0 then the value was shown 00001

.sh:value = 00010
.sh:set = 1
.sh:in = 1
.sh:dir = 0
.sh:set = 1
# shows 00101 the last bit comes from the in bit if it was .sh:in = 0 then the value was shown 00100

#if the comp is circular then the in value is not taken into account because the in value is equal with the out value

====
 as vrea sa mai adaugam o componenta numita rotary
comp [rotary] 4bit .rot:
    text: "R1"
    states: 6
    color: ^3F3
    :
#this executes 
addRotaryKnob({
   label, // this comes from text, if text is not set it should be ""
   states,
   color,
   onChange, //this should be the same as for dipSwitches or other components
})

.rot:data = 0010 
.rot:set = 1 
#the :set property is just like other components
#this sets the state of the rotary knob to :data = 0010 which is the 3rd state
#i think it should call a setRotaryKnob(id, newState) but method that doesn't exist now, can you create it?
#trying to set a state that is bigger then the number of states defined should silently set it to the biggest value possible meaning the number of states.

show(.rot:get)
#shows 0010 because that's the stat we've set it at, if no state was set before the state is 0 of course.





====
vreau sa adaug componenta lcd 
comp [lcd] 4bit .lcd1:
  row: 8
  cols: 6
  pixelSize: 7
  pixelGap: 1
  glow
  round
  color: ^58f
  bg: ^000
  nl
  :
#vezi mai multe informatii in js function addCharacterLCD
#ar trebuii sa execute
addCharacterLCD({
  id: someGeneratedStringId6,
  rows: 8,
  cols: 6,
  pixelSize: 7,
  pixelGap:1,
  glow: true,
  pixelOnColor: "#58f",
  backgroundColor: "#000",
  round: false, 
  nl: true,
});
#unele attribute pot sa lipseasca caz in care defaultul din addCharacterLCD va fi folosit


.lcd1:clear = 1
.lcd1:set = 1
#ar trebuii sa nu mai afiseze nimic pe ecran vezi CharacterLCD
# daca nu exista o metoda care sa faca asta te rog sa adaugi tu

.lcd1:x = 1
.lcd1:y = 0
.lcd1:rowlen = 101
.lcd1:data = 0111010001100000111000001100010111000000
.lcd1:set = 1
#acest set ar trebuii sa apeleze
lcdDisplays.get("lcd1").setRect(
  0, 1,
  {
  0: "01110",
  1: "10001",
  2: "10000",
  3: "01110",
  4: "00001",
  5: "10001",
  6: "01110",
  7: "00000"
});
#cu rows = x cu cols = y
#rowlen inseamna cati biti sunt pe fiecare rand
#in data sunt datele tuturor bitilor

≈===========
maybe
=====

i want to add a new idea instead of comp use pcb to define user defined chips or user defined components:

pcb +[comp1]: 
   4pin adr
   8pin data
   1pin write
   1pin set
   8pout get
   exec: set
#this exec is a new attribute which connects which value will trigger the execution of this component
#by default exec value is set meaning a this component must have a 1bit set variable already defined before this row
#but you can set a new variable name here like exec: execute where execute was defined before as 1bit execute
   on: raise
#this on: raise is like in the existing components and tells how this user defined component will be executed
#the values are like the normal components meaning on: 1 and on: edge

   comp [mem] .ram:
      depth: 2
      length: 16
      on: 1
      :
      
   .ram:at = adr
   .ram:set = 0
   
   get = .ram:get
   
   ~~
   .ram:{
       at = adr
       #here we say at propety equals 4pin adr variable, 
       data = data
       #here we say data propety equals 8pin data variable, 
       set = set 
       #here we say set propety equals 1pin set variable, 
   }
   get = MUX1(set, .ram:get, ^00)
   #here we say that the 8pout get value will be   = MUX(set, .ram:get, ^00)
   :1bit set

#this will define the pcb called comp1.
#the syntax for a definition is: pcb +[nameOfNewComponent]:
#you cannot use names of user defined components that already exists or reserved components like mem, shifter, counter, lcd, 7seg 
#the name must start with a letter and can continue with letters or numbers the name is case sensitive, for this example the name is comp1 and is valid.
#4pin adr is a variable of type 4wire, pin tells us that it's an input
#8pout get is a variable of type 4wire, pout tells us that it's an output
#it defines a comp .ram of type [mem] this .ram exists as name only in this pcb block scope, out of pcb block scope .ram doesn't exist and the user can use .ram for a different compoent. maybe implement .ram as _comp1.ram or something like this.
#in the same way the pin and pout only exists in this pcb block scope.
#in this pcb block scope you cannot use variables out of this pcb block scope, or variables that were defined before.. the only way in is thru pin variables and the only way out of data is thru pout variables.
#any functions defined before can be used in the pcb block scope including keyword functions like AND, OR, NOR, and user defined functions that were defined with def or loaded from other scripts
#~~ is a new section of the pcb definition that tells us what statements will be executed at NEXT(~)
#this ~~ section is optional and may be missing
#:1bit set means that when the pcb component will be called with no property it will return a 1bit value of the 1pin set variable
#instead of :1bit set you can also write : which means when the pc component will be called with no property it will not return anything


pcb [mychip]:
   8pin din
   8pout dout
   comp [counter] .c:
     depth:4
     =0000
     :
     
   .c:dir = 1
   .c:set = ~
   dout = .c:get + ^F
   :
   
#this is an example that has no ~~ section

pcb [comp1] .a::
#this is how we define a variable .a to be a pcb user defined component
#you cannot use .comp1 because there is no .comp1 nor comp1, you can use .a as a [comp1] and then set the properties for it


pcb [comp1] .b::
#this is another variable .b to be a [comp1] user pcb component just like writting comp [mem] .a
#the end of the definition is by using twice the symbol ::

.a:data = 1
.a:write = 1
.a:set = 1
#you can set the inputs like this 
#.a:set = 1 like in any component means it will execute the pcb block because it was set in exec:set

.a:{
  data = 1
  write = 1
  set = ~
}
#or like this as any component block
#.a:set = ~ means this propery block it will execute on the next execution of NEXT(~) just like any normal component


show(.a:get)
#this will show the value that was set in the 8pout get

show(.a)
#this will show the value in the 1pin set becuse that's how it what was defined in the component pcb [comp1] row to be :2bit set 



=======


.lcd1:{
   clear = 1
   x = .c:get
   y = 0
   rowlen = 101
   chr = ^4 + 0 + .c:get
   set = ~
}


I want a to have a new way of setting properties at once for a component
.lcd1:{
   clear = 1
   x = .c:get
   y = .mp:get
   rowlen = 101
   chr = ^4 + 0 + .c:get
   set = ~
}

this means that if .c:get changes all these propreties are executed not just the   x = .c:get and chr = ^4 + 0 + .c:get
and if .mp:get changes all these propreties are executed not just the  y = .mp:get this means that this code should clear the lcd and should call setRect. the assignations should be executed in the exact order.

this is also valid:

.lcd1:{
   clear = 1
   x = .c:get
   y = .mp:get
   rowlen = 101
   chr = ^4 + 0 + .c:get
   set = ~

   x = 1 
   y = 1
   rowlen = 1
   data = a1bitWire
   set = ~
}

this should happen for any component not just [lcd]

comp [rotary] 4bit .rot:
    text: "R1"
    states: 6
    color: ^3F3
    :

.rot:{
   data = 0010 
   set = 1
}

show(.rot:get)
====
Vreau sa adaug ! ca fiind un not inline si face ca valorile sa isi schimbe valoarea precum not pe fiecare bit exemplu:

3wire a = 100
4wire b = !0000 
#b va avea valoarea 1111
4wire c = !^F
#c va avea valoarea 0000
4wire d = !c
#d va avea valoarea 1111

#Atentie la + 
8wire a2 = !c + a
#a2 va avea valoarea 1111100 pentru ca ! schimba doar valoarea lui c deci 1111 concatenat cu valoarea lui a neschimbata

#bit range:
2wire a3 = !a.1/2 
#a3 va avea valoarea 11

2wire a4= !a.0 + !a.1
#a4 va avea valoarea 01

16wire c2 = !^FF0F
#c2 va avea valoarea ^00F0
32wire c3 = !^FF0F 000F
#c3 va avea valoarea ^00F0 FFF0


======

Vreau ca sa adaug shortname pentru fiecare componenta astfel:
comp [7seg]1bit .seg:  
#se poate scrie si astfel:
comp [7]1bit .seg:
Adica shortname-ul pentru [7seg] este [7].
Restul de componente vor avea aceste shortnameuri:
[adder] [+]
[subtract] [-]
[multiplier] [*]
[divider] [/]
[shifter] [>]
[counter] [=]


======
Vreau sa adaug posibilitatea ca o componenta sa fie definita astfel:
comp [lcd]7bit .lcd1 ::
Adica simbolul :: inseamna ca nu exista atribute in configuratie, se vor folosii valorile default.

comp [lcd]7bit .lcd1 ::

inseamna acelasi lucru ca:
comp [lcd]7bit .lcd1 :
   :

Simbolul :: este deja folosit la pcb astfel: 
pcb [userDefinedComp] .numeVariabla ::

====

Vreau sa adaug o componenta noua numita reg care sa se comporte ca un registry 

comp [reg]8bit .r1:
      depth: 2
      on: 1
      :
====
Vreau sa mai adaug o variabila speciale:

% este o variabila speciala care are valoarea 1 doar la prima rulare adica atunci cand se executa run().  Cand se termina prima rulare % devine 0. Nu este un wire. Daca devine 0 nu trebuie sa reexecute statements. Dar daca se vor reexecutau in caz ca se apasa ceva sau se schimba vre-un state dupa ce s-a terminat executia lui run() atunci % va avea valoarea 0. 

$ este o variablila speciala care la fiecare NEXT(~) va avea o valoare random 1 sau 0. Dar Bit range daca este folosit pe variabila speciala $ va avea un alt efect, si anume va da un bit random pentru fiecare bit cerut exemplu: 

1wire q = $
#valoarea lui q va fi la fiecare NEXT(~) un alt bit
1wire q = $.0 
#valoarea lui q va fi la fiecare NEXT(~) un alt bit
1wire q = $.2
#valoarea lui q va fi la fiecare NEXT(~) un alt bit
2wire q = $.0-1
#0-1 are length 2 deci returneaza 2 biti random la fiecare NEXT(~)
4wire q = $.2-5
#2-5 are length 4 deci returneaza 4 biti random la fiecare NEXT(~)

4wire q = $.2/4
#2/4 are length 4 deci returneaza 4 biti random la fiecare NEXT(~)
4wire q = $.0/4
#2/4 are length 4 deci returneaza 4 biti random la fiecare NEXT(~)

