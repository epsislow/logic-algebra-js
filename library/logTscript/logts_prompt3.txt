please check script_editor_v0_3_1_last_version.html and lib/main.js. 
I want a way to add devices from the script and give values or connect them to existing references, examples:

#when executing the script, on run() the devices() will be cleared.

2wire a = 11

comp [led] 1bit .power:
     text: "PWR"
     color: ^2ecc71
     = 0
     :

# this adds the device component .power that has a 1bit input 
# the text is the label attribute of the led that will be added in the devices  
# the color is the color attribute of the led 
# the = 0 is the value given when the devices is added 
# it should execute the js function: 
#addLed({
#  id: someGeneratedStringId,
#  text: "PWR",
#  color: "#2ecc71",
#  value: true
#});


.power = a.0
#this connects the value of the led to the reference a.0 -> the first bit of a is 1 -> led lights on
#this means that if a.0 value changes the led should show the change 
# executs the js function
# setLed( someGeneratedStringId, true);


a = 00
#when this assignment happens because the first bit of a is now 0 -> led lights off
# executs the js function
# setLed( someGeneratedStringId, false)

a.0 = 1
#when this assignment happens because the first bit of a is now 1 -> led lights on
# executs the js function
# setLed( someGeneratedStringId, true)

comp [led] 1bit .error:
     color: ^f44
     text:"ERR"
     :
#the attributes can be given in any order, the color can be short like in css
#value can be missed this means it will be 0
#will execute:
#addLed({
#  id: someGeneratedStringId2,
#  text: "ERR",
#  color: "#f44",
#  value: false
#});

.error = 1
.power = 0

comp [led] 1bit .test:
   color: ^f0f,
   radius: 0
   :
#text can be missed this means it won't have a label 
#radius is another attribute that gets into the js execution
#will execute:
#addLed({
#  id: someGeneratedStringId3,
#  color: "#f0f",
#  radius: 0,
#  value: false
#});


comp [led] 6bit .l:
    color: ^00ff99
    text: "OUT"
    radius: 0
    nl
    :
#this led has 6bits this means it converts into 6 consecutive leds
#the text is for the first led js execution
#nl attribute translates into the js execution as nl: true in the last led 
#will execute a js like this:
#addLed({ text: 'OUT',  id: "l.1", color: "#00ff99", value: false, radius:0 });
#addLed({ id: "l.2", color: "#00ff99", value: false, radius:0 });
#addLed({ id: "l.3", color: "#00ff99", value: false, radius:0 });
#addLed({ id: "l.4", color: "#00ff99", value: false, radius:0 });
#addLed({ id: "l.5", color: "#00ff99", value: false, radius:0 });
#addLed({ id: "l.6", color: "#00ff99", value: false, radius:0, nl: true });

.l = 000001
#this assignemnt will trigger the led light changes accordingly
#executes: 
#setLed("l.1", false);
#setLed("l.2", false);
#setLed("l.3", false);
#setLed("l.4", false);
#setLed("l.5", false);
#setLed("l.6", true);

comp [led] 6bit .t:
    color:^0f9
    text: "OUT2"
    radius: 0
    = 011011
    nl
    :

# the : is the return of the definition block and it means that the led components cannot be assigned to other values 

1bit ret = .t 
#this gives an error that ret cannot be assigned to a 0 bit component

comp [switch] 1bit .wifi:
    text: "WIFI"
    :1bit
#this is the switch component 
# the text is the label attribute
# it has a 1bit return that is the value that will change when the checkbox changes state (onclick)
# executes: 
#addSwitch({
#    text: "WIFI",
#    value: true,
#    onChange: state => someInternalInterpretorMethod
#});

.power = .wifi
#this is connects the .power led with the value of the .wifi switch
#when the .wifi checkbox is pressed it will execute the js someInternalInterpretorMethod and the value of the .power will change checked means = 1 not checked means 0
#it should execute a setLed()

.l.0 = .wifi 
#this also works
#this means that the first bit of .l comes from the state of the .wifi checkbox
#it should execute a setLed() 




The switches that are checkboxes will trigger changes because the coresponding components change the value of the conected references and those references are connected with other elements functions/statements inside script and those should also be processed.

2bit a = 01

comp [led] 1bit .power:
     text: "PWR"
     color: ^2ecc71
     = 0
     :


comp [switch] 1bit .wifi:
    text: "WIFI"
    :1bit


.power = .wifi


========
acum pentru programul:

2bit a = 01

comp [led] 1bit .power:
     text: "PWR"
     color: ^0000ff
     = 0
     :


comp [switch] 1bit .wifi:
    text: "WIFI"
    :1bit


.power = .wifi

afiseaza corect acum, dar cand apas pe checkbox  pare ca nu se schimba nimic 
Am adaugat un console.log la linia 3004:
console.log('CHECK ' , checked, compInfo);

if(compInfo){
          // Update the value in storage if component is connected
          if(compInfo.ref){
            const storageIdx = parseInt(compInfo.ref.substring(1));
                const stored = this.storage.find(s => s.index === storageIdx);
                if(stored){
                  stored.value = checked ? '1' : '0';
                  // Update all connected components
                  this.updateComponentConnections(name);
                }
          }
        }

vad in console ca ref = null :
CHECK  true 
Object { type: "switch", componentType: "1bit", attributes: {…}, initialValue: null, returnType: "1bit", ref: null, deviceIds: (1) […] }
​attributes: Object { text: "WIFI" }
componentType: "1bit"
deviceIds: Array [ "wifi" ]
initialValue: null
ref: null
returnType: "1bit"
type: "switch"
<prototype>: Object { … }

dar cred ca ref este referinta de intrare precum componenta LED care ii spune daca led este aprins sau nu 

pentru ca vad ca pe componenta led .power adica daca execut:
globalInterp.components.get('.power')

imi arata:
Object { type: "led", componentType: "1bit", attributes: {…}, initialValue: "0", returnType: null, ref: "(0)", deviceIds: (1) […] }
​attributes: Object { text: "PWR", color: "#0000FF" }​
componentType: "1bit"
deviceIds: Array [ "power" ]
initialValue: "0"
ref: "(0)"
returnType: null
type: "led"

iar switch nu are o astfel de referinta are doar de iesire,
ma gandesc ca ar trebuii sa fie referinte diferite daca o componenta poate sa aibe si referinta de intrare si de iesire?

.power = .wifi 
inseamna ca .wifi ar trebuii sa schimbe state-ul unei referinte de iesire deci sa aibe un storage nou. iar .power sa fie conectat cu referinta lui de intrare la referinta de iesire a lui .wifi 

astfel incat sa aprinda sau sa stinga ledul conform cu stateul butonului


===
as vrea sa modificam attributul radius pt componentele led sa se numeasca square
si sa nu mai fie folosit radius: 0 ci doar square adica:
in loc de 
comp [led] 1bit .power:
     text: "PWR"
     color: ^ff0
     radius: 0
     = 1
     :

sa scriem:
comp [led] 1bit .power:
     text: "PWR"
     color: ^ff0
     square
     = 1
     :

care executa in js atributul round: 0
iar daca square  lipseste atunci in js nu va trimite atributul round 

===== comp lcd/pcb ideas

16bit b = 1111011011110110

comp [7seg] 8bit .s1:
   text: "R"
   color: ^2c7
   :
comp [7seg] 8bit .s2:

.s1 = b.0/8
.s2 = b.8/8

comp [dip] 8bit .dp:
   text: "IN"
   color: ^f37
   :8bit

.b.0/8 = .dp

conp [lcd] 40bit .lcd1:
  row: 8
  cols: 5
  pixelSize: 7
  pixelGap: 1
  glow
  round: 0
  color: ^58f
  bg: ^000
  nl
  :
  
  
pcb [display] {
   1pin sel
   8pin data
   ...
   .lcd0 = bus8wire
#   8pout q
}


comp [display] 9bit .d2:



comp [lcd-ctrl] 8bit lcd1Ctrl:
   for: .lcd1
   :

1bit sel
5bit instr = 00001
3bit param = 101

.lcdCtrl = sel + instr + param
next
sel = 0
inste = 3
next


.lcd1 = ^7FF5 F301 4E

send .lcd1:
   x: 111
   y: 100
   len: 4
   data: ^035
   :

send .lcd1:
   clear
   color: ^f9f
   :




addCharacterLCD({
  id: "lcd2",
  rows: 8,
  cols: 30,
  pixelSize: 7,
  pixelGap:1,
  glow: true,
  pixelOnColor: "#5588ff",
  backgroundColor: "#000",
  round: false, 
  nl: true,
});


comp [key] 

====
