please check script_editor_v0_3_1_last_version.html and lib/main.js. 
I want a way to add devices from the script and give values or connect them to existing references, examples:

#when executing the script, on run() the devices() will be cleared.

2wire a = 11

comp [led] 1bit .power:
     text: "PWR"
     color: ^2ecc71
     = 0
     :

# this adds the device component .power that has a 1bit input 
# the text is the label attribute of the led that will be added in the devices  
# the color is the color attribute of the led 
# the = 0 is the value given when the devices is added 
# it should execute the js function: 
#addLed({
#  id: someGeneratedStringId,
#  text: "PWR",
#  color: "#2ecc71",
#  value: true
#});


.power = a.0
#this connects the value of the led to the reference a.0 -> the first bit of a is 1 -> led lights on
#this means that if a.0 value changes the led should show the change 
# executs the js function
# setLed( someGeneratedStringId, true);


a = 00
#when this assignment happens because the first bit of a is now 0 -> led lights off
# executs the js function
# setLed( someGeneratedStringId, false)

a.0 = 1
#when this assignment happens because the first bit of a is now 1 -> led lights on
# executs the js function
# setLed( someGeneratedStringId, true)

comp [led] 1bit .error:
     color: ^f44
     text:"ERR"
     :
#the attributes can be given in any order, the color can be short like in css
#value can be missed this means it will be 0
#will execute:
#addLed({
#  id: someGeneratedStringId2,
#  text: "ERR",
#  color: "#f44",
#  value: false
#});

.error = 1
.power = 0

comp [led] 1bit .test:
   color: ^f0f,
   radius: 0
   :
#text can be missed this means it won't have a label 
#radius is another attribute that gets into the js execution
#will execute:
#addLed({
#  id: someGeneratedStringId3,
#  color: "#f0f",
#  radius: 0,
#  value: false
#});


comp [led] 6bit .l:
    color: ^00ff99
    text: "OUT"
    radius: 0
    nl
    :
#this led has 6bits this means it converts into 6 consecutive leds
#the text is for the first led js execution
#nl attribute translates into the js execution as nl: true in the last led 
#will execute a js like this:
#addLed({ text: 'OUT',  id: "l.1", color: "#00ff99", value: false, radius:0 });
#addLed({ id: "l.2", color: "#00ff99", value: false, radius:0 });
#addLed({ id: "l.3", color: "#00ff99", value: false, radius:0 });
#addLed({ id: "l.4", color: "#00ff99", value: false, radius:0 });
#addLed({ id: "l.5", color: "#00ff99", value: false, radius:0 });
#addLed({ id: "l.6", color: "#00ff99", value: false, radius:0, nl: true });

.l = 000001
#this assignemnt will trigger the led light changes accordingly
#executes: 
#setLed("l.1", false);
#setLed("l.2", false);
#setLed("l.3", false);
#setLed("l.4", false);
#setLed("l.5", false);
#setLed("l.6", true);

comp [led] 6bit .t:
    color:^0f9
    text: "OUT2"
    radius: 0
    = 011011
    nl
    :

# the : is the return of the definition block and it means that the led components cannot be assigned to other values 

1bit ret = .t 
#this gives an error that ret cannot be assigned to a 0 bit component

comp [switch] 1bit .wifi:
    text: "WIFI"
    :1bit
#this is the switch component 
# the text is the label attribute
# it has a 1bit return that is the value that will change when the checkbox changes state (onclick)
# executes: 
#addSwitch({
#    text: "WIFI",
#    value: true,
#    onChange: state => someInternalInterpretorMethod
#});

.power = .wifi
#this is connects the .power led with the value of the .wifi switch
#when the .wifi checkbox is pressed it will execute the js someInternalInterpretorMethod and the value of the .power will change checked means = 1 not checked means 0
#it should execute a setLed()

.l.0 = .wifi 
#this also works
#this means that the first bit of .l comes from the state of the .wifi checkbox
#it should execute a setLed() 




The switches that are checkboxes will trigger changes because the coresponding components change the value of the conected references and those references are connected with other elements functions/statements inside script and those should also be processed.

2bit a = 01

comp [led] 1bit .power:
     text: "PWR"
     color: ^2ecc71
     = 0
     :


comp [switch] 1bit .wifi:
    text: "WIFI"
    :1bit


.power = .wifi


========
acum pentru programul:

2bit a = 01

comp [led] 1bit .power:
     text: "PWR"
     color: ^0000ff
     = 0
     :


comp [switch] 1bit .wifi:
    text: "WIFI"
    :1bit


.power = .wifi

afiseaza corect acum, dar cand apas pe checkbox  pare ca nu se schimba nimic 
Am adaugat un console.log la linia 3004:
console.log('CHECK ' , checked, compInfo);

if(compInfo){
          // Update the value in storage if component is connected
          if(compInfo.ref){
            const storageIdx = parseInt(compInfo.ref.substring(1));
                const stored = this.storage.find(s => s.index === storageIdx);
                if(stored){
                  stored.value = checked ? '1' : '0';
                  // Update all connected components
                  this.updateComponentConnections(name);
                }
          }
        }

vad in console ca ref = null :
CHECK  true 
Object { type: "switch", componentType: "1bit", attributes: {…}, initialValue: null, returnType: "1bit", ref: null, deviceIds: (1) […] }
​attributes: Object { text: "WIFI" }
componentType: "1bit"
deviceIds: Array [ "wifi" ]
initialValue: null
ref: null
returnType: "1bit"
type: "switch"
<prototype>: Object { … }

dar cred ca ref este referinta de intrare precum componenta LED care ii spune daca led este aprins sau nu 

pentru ca vad ca pe componenta led .power adica daca execut:
globalInterp.components.get('.power')

imi arata:
Object { type: "led", componentType: "1bit", attributes: {…}, initialValue: "0", returnType: null, ref: "(0)", deviceIds: (1) […] }
​attributes: Object { text: "PWR", color: "#0000FF" }​
componentType: "1bit"
deviceIds: Array [ "power" ]
initialValue: "0"
ref: "(0)"
returnType: null
type: "led"

iar switch nu are o astfel de referinta are doar de iesire,
ma gandesc ca ar trebuii sa fie referinte diferite daca o componenta poate sa aibe si referinta de intrare si de iesire?

.power = .wifi 
inseamna ca .wifi ar trebuii sa schimbe state-ul unei referinte de iesire deci sa aibe un storage nou. iar .power sa fie conectat cu referinta lui de intrare la referinta de iesire a lui .wifi 

astfel incat sa aprinda sau sa stinga ledul conform cu stateul butonului


===
as vrea sa modificam attributul radius pt componentele led sa se numeasca square
si sa nu mai fie folosit radius: 0 ci doar square adica:
in loc de 
comp [led] 1bit .power:
     text: "PWR"
     color: ^ff0
     radius: 0
     = 1
     :

sa scriem:
comp [led] 1bit .power:
     text: "PWR"
     color: ^ff0
     square
     = 1
     :

care executa in js atributul round: 0
iar daca square  lipseste atunci in js nu va trimite atributul round 

===== comp lcd/pcb ideas

16bit b = 1111011011110110

comp [7seg] 8bit .s1:
   text: "R"
   color: ^2c7
   :
comp [7seg] 8bit .s2:
   color: ^2c7
   nl
   :

.s1 = b.0/8
.s2 = b.8/8

comp [dip] 8bit .dp:
   text: "IN"
   color: ^f37
   :8bit

.b.0/8 = .dp

conp [lcd] 40bit .lcd1:
  row: 8
  cols: 5
  pixelSize: 7
  pixelGap: 1
  glow
  round: 0
  color: ^58f
  bg: ^000
  nl
  :
  
  
pcb [display] {
   1pin sel
   8pin data
   ...
   .lcd0 = bus8wire
#   8pout q
}


comp [display] 9bit .d2:



comp [lcd-ctrl] 8bit lcd1Ctrl:
   for: .lcd1
   :

1bit sel
5bit instr = 00001
3bit param = 101

.lcdCtrl = sel + instr + param
next
sel = 0
inste = 3
next


.lcd1 = ^7FF5 F301 4E

send .lcd1:
   x: 111
   y: 100
   len: 4
   data: ^035
   :

send .lcd1:
   clear
   color: ^f9f
   :




addCharacterLCD({
  id: "lcd2",
  rows: 8,
  cols: 30,
  pixelSize: 7,
  pixelGap:1,
  glow: true,
  pixelOnColor: "#5588ff",
  backgroundColor: "#000",
  round: false, 
  nl: true,
});


comp [key] 

====
vreau sa adaugam compoenta 7seg 
comp [7seg] 8bit .s1:
   text: "SEG"
   color: ^2ecc71
   = 00001111
   nl
   :
# text atribut pentru labelul pentru sevenSegment ca la celelalte componente
# color pentru culoare ca la celelalte componente
# nl ca la celelalte componente
# = seteaza valoarea de 8 biti data sau o referinta ca la celelalte componente
# executa js:
addSevenSegment({
  text: "SEG",
  color: "#2ecc71",
  values: "00001111"
});

# atributele sunt optionale ca la celalalte componente
comp [7seg] 8bit .s2:
   nl
   :
#executa doar
addSevenSegment({
    nl: true
});

=====
i want to add a new component called mem:

comp [mem] 4bit .ram:
   length: 3
   depth: 4
   = ^0
   :
#this should have a js function like addMem({ length: 3, depth: 4, default: "0000" })
#this component doesn't add anything to the display
#depth attribute sets the number of bits each memory address is having, default is 4 meaning 4 bits
#length attribute sets the number of addresses that exists in the memory component
#= is the default value that each address will have, must be the same bit length set with depth attribute


#should execute the addMem() js function like:
addMem({
 id: someGeneratedStringId5,
 length: 3,
 depth: 4,
 default: "0000"
});

#the addMem function should keep the memory data in an object or Map for each id 
#there should be also a js function called setMem( id, address, value) that sets the value of an memory address to the given value be also a js function called setMem( id, address, 
#there should be also a js function called getMem( id, address) and should return the value of the memory with given id and address, if the memory doesn't have a value set on that address should give the default value.
#the addMem should not create all the addresses initialy, just use the default functionality. if the default value is not set by default is 0 

#the attributes are optional like the rest of the components. the defaults are: length= 3, depth= 4 and each address have the value 0

.ram = ^FFF
#should give error: Cannot asign a value to a mem component


.ram:at = 00
#sets the memory address where we want to do some operation, must be between 0 and the given length, 
#.ram:at = 11 should give error: Memory invalid address 3 ( length: 3 means adress can be between 0,1 or 2)
.ram:data = ^5
#sets the value for the said address
.ram:set = 1
#the value is changed imediatly, 
.ram:set = ~
#the value is changed on the next NEXT(~)

.ram:at = 00
.ram:data = ^5F
.ram:set = 1
#this will change the memory values: for address 0 to bits of 5, and the next address 1 to bits of F
#you can perform multiple sets by given more bits to data, the number of bits must be divizibile with the depth number. If depth is 6 meaning 6bit then .ram:data must be 6bits, 12bits, 18bits, 24bits etc..

.ram:adr = 00
4bit val = .ram:get
#this assigns to val the value that exists at adresss 0 at component .ram, should use a js method like getMem(id, address)

.ram:get = 0
#this throws an error: Invalid get property cannot be assigned to a value

other examples:
comp [mem] 4bit .rom:
   depth: 8
   length: 256
   :
#this adds a mem componet called .rom with 8bits depth and 256 memory addresses default value is 00000000


.rom:at = 0
.rom:data = ^1234 5678 9ABC + ^DF
.rom:set = 1
#this sets 7 values for address 0 to 6 now

5bit adr = 00100
8bit val2 = ^0
.rom:at = adr
.rom:data = val2
.rom:set = ~
#this will set for address 5 the value 0 when NEXT(~)  will be executed
=====

add counter component 

comp [counter] 5bit .c:
   depth: 5
   = 00100
   :
#this should have a js function like addCounter({ depth: 4, default: "0000" })
#if no default is set then use 0
#this should execute:
#addCounter({depth: 5, default: "00100" })


.c:dir = 1
#sets the direction to increment
.c:data = 10100
#sets the date to be 10100 
.c:set = 1
#the value is changed imediatly and because the direction is increment it will changed to 10101 
#if the value was 11111 then the increment should change it to 00000

.c:set = ~
#the value is changed on the next NEXT(~) 

.c:dir = 0
#sets the direction to decrement
.c:data = 00000
.c:set = 1
#the value is changed imediatly and because the direction is decrement it will be changed to 11111


show(.c:get) 
#this should show the current value of the counter meaning 11111
=========================


as vrea sa mai adaugam o componenta numita adder:
comp [adder] 4bit .add:
   depth: 4
   :

#this should have a js function like addAdder({ depth: 4})
#if no value was set for depth then use depth: 4

.add:a = 1011
.add:b = 0100
#sets the numbers a and b
show(.add:get)
#shows 1111

.add:a = 0001
.add:b = 1111
show(.add:get)
#shows 0000
show(.add:carry)
#shows 1. the carry value is the first overflow bit after the a + b calculation

.add:a = 0010
.add:b = 1111
show(.add:get)
#shows 0001
show(.add:carry)
#shows 1

comp [adder] 8bit .add:
   depth: 8
   :
   

.add:a = 00000001
.add:b = 00001111
show(.add:get)
#shows 00010000
show(.add:carry)
#shows 0 the value is 0 because the a+b calculation gave no carry

=====



as vrea sa mai adaugam o componenta numita subtract:
comp [subtract] 4bit .sub:
   depth: 4
   :

.sub:a = 1111
.sub:b = 0110
show(.sub:get)
#shows 1001 shows the result of a - b
show(.sub:carry)
#shows 0  shows the carry after a - b

.sub:a = 0000
.sub:b = 0001
show(.sub:get)
#shows 1111 shows the result of a - b
show(.sub:carry)
#shows 1  shows the carry after a - b

====
as vrea sa mai adaugam o componenta numita divider:
comp [divider] 4bit .div:
   depth: 4
   :

.div:a = 1110
.div:b = 0010
show(.div:get)
#shows 0111 shows the result of a / b
show(.div:mod)
#shows 0000 shows the modulo of a / b

.div:a = 0111
.div:b = 0010
show(div:get)
#shows 0011
show(.div:mod)
#shows 0001 
====
as vrea sa mai adaugam o componenta numita multiplier
comp [multiplier] 4bit .mul:
    depth: 4
    :
    
.mul:a = 0010
.mul:b = 0010
show(.mul:get)
#shows 0100 shows the result of a * b
show(.mul:over)
#shows 0000 shows the carry over after the result of a * b

.mul:a = 1111
.mul:b = 1111
show(.mul:get)
#shows 0001 shows the result of a * b
show(.mul:over)
#shows 1110 shows the carry over after the result of a * b

====

 i want to add a component for a shift register that can shift to left or to right 
comp [shifter] 8bit .sh:
   depth: 8
   :

.sh:value = 00110111
.sh:set = 1
#this should set this value in the shifter

that could be done with an attribute like direction :dir
.sh:dir = 1 
#meaning shifting to right or
.sh:dir = 0
#meaning shifting to left
.sh:set = 1
#the shifting is done now

show(.sh:get) 
#shows 00011011 shows the shifter value of 8bits and take into account if the shifter has circular set or not
show(.sh:out)
#shows 1 shows the bit that was shifted out 

comp [shifter] 8bit .sh2:
   depth: 8
   circular
   :
#this shifter is circular 

.sh:value = 00110111
.sh:dir = 0
.sh:set = 1
#the shifting is done now

show(.sh:get)
#shows 10011011
show(.sh:out)
#shows 1 shows the bit that was shifted out 


== 
i want to add :in for the shifter component:
comp [shifter] 5bit .sh2:
   depth: 5
   :

.sh:value = 00010
.sh:set = 1
.sh:in = 1
# this will be used when the shifter is not circular, 
# and will use the bit to the shifter like folowing:
.sh:dir = 1
.sh:set = 1
show(.sh:get)
# shows 10001 the first bit comes from the in bit if it was .sh:in = 0 then the value was shown 00001

.sh:value = 00010
.sh:set = 1
.sh:in = 1
.sh:dir = 0
.sh:set = 1
# shows 00101 the last bit comes from the in bit if it was .sh:in = 0 then the value was shown 00100

#if the comp is circular then the in value is not taken into account because the in value is equal with the out value
